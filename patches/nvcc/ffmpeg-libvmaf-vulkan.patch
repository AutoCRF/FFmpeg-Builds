diff --git a/configure b/configure
index c931b86..b36f429 100755
--- a/configure
+++ b/configure
@@ -290,6 +290,7 @@ External library support:
   --enable-libv4l2         enable libv4l2/v4l-utils [no]
   --enable-libvidstab      enable video stabilization using vid.stab [no]
   --enable-libvmaf         enable vmaf filter via libvmaf [no]
+  --enable-libvmaf-vulkan  enable Vulkan-accelerated vmaf filter via libvmaf [no]
   --enable-libvo-amrwbenc  enable AMR-WB encoding via libvo-amrwbenc [no]
   --enable-libvorbis       enable Vorbis en/decoding via libvorbis,
                            native implementation exists [no]
@@ -1987,6 +1988,7 @@ EXTERNAL_LIBRARY_LIST="
     libuavs3d
     libv4l2
     libvmaf
+    libvmaf_vulkan
     libvorbis
     libvpx
     libvvenc
@@ -4063,6 +4065,7 @@ vidstabdetect_filter_deps="libvidstab"
 vidstabtransform_filter_deps="libvidstab"
 libvmaf_filter_deps="libvmaf"
 libvmaf_cuda_filter_deps="libvmaf libvmaf_cuda ffnvcodec"
+libvmaf_vulkan_filter_deps="libvmaf libvmaf_vulkan vulkan"
 zmq_filter_deps="libzmq"
 zoompan_filter_deps="swscale"
 zscale_filter_deps="libzimg const_nan"
@@ -7167,6 +7170,8 @@ enabled libv4l2           && require_pkg_config libv4l2 libv4l2 libv4l2.h v4l2_i
 enabled libvidstab        && require_pkg_config libvidstab "vidstab >= 0.98" vid.stab/libvidstab.h vsMotionDetectInit
 enabled libvmaf           && require_pkg_config libvmaf "libvmaf >= 2.0.0" libvmaf.h vmaf_init
 enabled libvmaf           && check_pkg_config libvmaf_cuda "libvmaf >= 2.0.0" libvmaf_cuda.h vmaf_cuda_state_init
+enabled libvmaf_vulkan    && require_pkg_config libvmaf "libvmaf >= 2.0.0" libvmaf.h vmaf_init &&
+                             check_pkg_config libvmaf_vulkan "libvmaf >= 2.0.0" libvmaf_vulkan.h vmaf_vulkan_state_init
 enabled libvo_amrwbenc    && require libvo_amrwbenc vo-amrwbenc/enc_if.h E_IF_init -lvo-amrwbenc
 enabled libvorbis         && require_pkg_config libvorbis vorbis vorbis/codec.h vorbis_info_init &&
                              require_pkg_config libvorbisenc vorbisenc vorbis/vorbisenc.h vorbis_encode_init
diff --git a/libavfilter/Makefile b/libavfilter/Makefile
index 07fb4c3..0ea63d9 100644
--- a/libavfilter/Makefile
+++ b/libavfilter/Makefile
@@ -374,6 +374,7 @@ OBJS-$(CONFIG_LENSFUN_FILTER)                += vf_lensfun.o
 OBJS-$(CONFIG_LIBPLACEBO_FILTER)             += vf_libplacebo.o vulkan.o vulkan_filter.o
 OBJS-$(CONFIG_LIBVMAF_FILTER)                += vf_libvmaf.o framesync.o
 OBJS-$(CONFIG_LIBVMAF_CUDA_FILTER)           += vf_libvmaf.o framesync.o
+OBJS-$(CONFIG_LIBVMAF_VULKAN_FILTER)         += vf_libvmaf.o framesync.o
 OBJS-$(CONFIG_LIMITDIFF_FILTER)              += vf_limitdiff.o framesync.o
 OBJS-$(CONFIG_LIMITER_FILTER)                += vf_limiter.o
 OBJS-$(CONFIG_LOOP_FILTER)                   += f_loop.o
diff --git a/libavfilter/allfilters.c b/libavfilter/allfilters.c
index cca4ce0..c03601f 100644
--- a/libavfilter/allfilters.c
+++ b/libavfilter/allfilters.c
@@ -348,6 +348,7 @@ extern const FFFilter ff_vf_lensfun;
 extern const FFFilter ff_vf_libplacebo;
 extern const FFFilter ff_vf_libvmaf;
 extern const FFFilter ff_vf_libvmaf_cuda;
+extern const FFFilter ff_vf_libvmaf_vulkan;
 extern const FFFilter ff_vf_limitdiff;
 extern const FFFilter ff_vf_limiter;
 extern const FFFilter ff_vf_loop;
diff --git a/libavfilter/vf_libvmaf.c b/libavfilter/vf_libvmaf.c
index 10d5b7f..c98ca06 100644
--- a/libavfilter/vf_libvmaf.c
+++ b/libavfilter/vf_libvmaf.c
@@ -46,6 +46,13 @@
 #include "libavutil/hwcontext_cuda_internal.h"
 #endif
 
+#if CONFIG_LIBVMAF_VULKAN_FILTER
+#include <libvmaf/libvmaf_vulkan.h>
+#include "libavutil/hwcontext.h"
+#include "libavutil/hwcontext_vulkan.h"
+#include "libswscale/swscale.h"
+#endif
+
 typedef struct LIBVMAFContext {
     const AVClass *class;
     FFFrameSync fs;
@@ -64,6 +71,10 @@ typedef struct LIBVMAFContext {
 #if CONFIG_LIBVMAF_CUDA_FILTER
     VmafCudaState *cu_state;
 #endif
+#if CONFIG_LIBVMAF_VULKAN_FILTER
+    VmafVulkanState *vk_state;
+    enum AVPixelFormat sw_planar_fmt;
+#endif
 } LIBVMAFContext;
 
 #define OFFSET(x) offsetof(LIBVMAFContext, x)
@@ -826,3 +837,238 @@ const FFFilter ff_vf_libvmaf_cuda = {
     .flags_internal = FF_FILTER_FLAG_HWFRAME_AWARE,
 };
 #endif
+
+#if CONFIG_LIBVMAF_VULKAN_FILTER
+
+/**
+ * Map semi-planar pixel formats (NV12, P010, etc.) to the equivalent
+ * fully-planar format that libvmaf / pix_fmt_map() understands.
+ */
+static enum AVPixelFormat vmaf_planar_fmt(enum AVPixelFormat fmt)
+{
+    switch (fmt) {
+    case AV_PIX_FMT_NV12:   return AV_PIX_FMT_YUV420P;
+    case AV_PIX_FMT_P010LE: return AV_PIX_FMT_YUV420P10LE;
+    case AV_PIX_FMT_P012LE: return AV_PIX_FMT_YUV420P12LE;
+    case AV_PIX_FMT_P016LE: return AV_PIX_FMT_YUV420P16LE;
+    default:                return fmt;
+    }
+}
+
+static AVFrame *convert_to_planar(AVFrame *src, enum AVPixelFormat dst_fmt)
+{
+    AVFrame *dst = av_frame_alloc();
+    struct SwsContext *sws;
+    if (!dst)
+        return NULL;
+    dst->format = dst_fmt;
+    dst->width  = src->width;
+    dst->height = src->height;
+    if (av_frame_get_buffer(dst, 0) < 0) {
+        av_frame_free(&dst);
+        return NULL;
+    }
+    sws = sws_getContext(src->width, src->height, src->format,
+                         dst->width, dst->height, dst_fmt,
+                         SWS_POINT, NULL, NULL, NULL);
+    if (!sws) {
+        av_frame_free(&dst);
+        return NULL;
+    }
+    sws_scale(sws, (const uint8_t *const *)src->data, src->linesize,
+              0, src->height, dst->data, dst->linesize);
+    sws_freeContext(sws);
+    return dst;
+}
+
+static int do_vmaf_vulkan(FFFrameSync *fs)
+{
+    AVFilterContext *ctx = fs->parent;
+    LIBVMAFContext *s = ctx->priv;
+    VmafPicture pic_ref, pic_dist;
+    AVFrame *ref, *dist;
+    AVFrame *ref_sw = NULL, *dist_sw = NULL;
+    int ret;
+
+    ret = ff_framesync_dualinput_get(fs, &dist, &ref);
+    if (ret < 0)
+        return ret;
+    if (ctx->is_disabled || !ref)
+        return ff_filter_frame(ctx->outputs[0], dist);
+
+    // Download Vulkan frames to CPU for processing.
+    // libvmaf's Vulkan extractors will re-upload to GPU internally, but
+    // we share the same VkDevice so there's no duplicate device overhead.
+    // True zero-copy (VkImage -> SSBO) is a future optimization.
+    ref_sw = av_frame_alloc();
+    dist_sw = av_frame_alloc();
+    if (!ref_sw || !dist_sw) {
+        ret = AVERROR(ENOMEM);
+        goto fail;
+    }
+
+    ret = av_hwframe_transfer_data(ref_sw, ref, 0);
+    if (ret < 0) {
+        av_log(ctx, AV_LOG_ERROR, "Failed to download ref frame: %s\n",
+               av_err2str(ret));
+        goto fail;
+    }
+    ret = av_hwframe_transfer_data(dist_sw, dist, 0);
+    if (ret < 0) {
+        av_log(ctx, AV_LOG_ERROR, "Failed to download dist frame: %s\n",
+               av_err2str(ret));
+        goto fail;
+    }
+
+    // Convert semi-planar (NV12/P010) to planar (YUV420P) for VMAF
+    if (ref_sw->format != s->sw_planar_fmt) {
+        AVFrame *tmp;
+        tmp = convert_to_planar(ref_sw, s->sw_planar_fmt);
+        if (!tmp) { ret = AVERROR(ENOMEM); goto fail; }
+        av_frame_free(&ref_sw);
+        ref_sw = tmp;
+        tmp = convert_to_planar(dist_sw, s->sw_planar_fmt);
+        if (!tmp) { ret = AVERROR(ENOMEM); goto fail; }
+        av_frame_free(&dist_sw);
+        dist_sw = tmp;
+    }
+
+    ret = copy_picture_data(ref_sw, &pic_ref, s->bpc);
+    if (ret) {
+        av_log(s, AV_LOG_ERROR, "problem during vmaf_picture_alloc.\n");
+        goto fail;
+    }
+    ret = copy_picture_data(dist_sw, &pic_dist, s->bpc);
+    if (ret) {
+        av_log(s, AV_LOG_ERROR, "problem during vmaf_picture_alloc.\n");
+        vmaf_picture_unref(&pic_ref);
+        goto fail;
+    }
+
+    ret = vmaf_read_pictures(s->vmaf, &pic_ref, &pic_dist, s->frame_cnt++);
+    if (ret) {
+        av_log(s, AV_LOG_ERROR, "problem during vmaf_read_pictures.\n");
+        ret = AVERROR(EINVAL);
+        goto fail;
+    }
+
+    ret = 0;
+fail:
+    av_frame_free(&ref_sw);
+    av_frame_free(&dist_sw);
+    if (ret < 0)
+        return ret;
+    return ff_filter_frame(ctx->outputs[0], dist);
+}
+
+static av_cold int init_vulkan(AVFilterContext *ctx)
+{
+    LIBVMAFContext *s = ctx->priv;
+    s->fs.on_event = do_vmaf_vulkan;
+    return 0;
+}
+
+static int config_props_vulkan(AVFilterLink *outlink)
+{
+    int err;
+    AVFilterContext *ctx = outlink->src;
+    LIBVMAFContext *s = ctx->priv;
+    AVFilterLink *inlink = ctx->inputs[0];
+    FilterLink *inl = ff_filter_link(inlink);
+    AVHWFramesContext *frames_ctx;
+    AVVulkanDeviceContext *vk_hwctx;
+    const AVPixFmtDescriptor *desc;
+    int queue_family = -1;
+
+    if (!inl->hw_frames_ctx) {
+        av_log(ctx, AV_LOG_ERROR,
+               "No Vulkan hw_frames_ctx on input. Use -hwaccel vulkan.\n");
+        return AVERROR(EINVAL);
+    }
+
+    frames_ctx = (AVHWFramesContext *)inl->hw_frames_ctx->data;
+    vk_hwctx = frames_ctx->device_ctx->hwctx;
+    desc = av_pix_fmt_desc_get(frames_ctx->sw_format);
+    s->bpc = desc->comp[0].depth;
+    s->sw_planar_fmt = vmaf_planar_fmt(frames_ctx->sw_format);
+
+    // Find a compute-capable queue family
+    for (int i = 0; i < vk_hwctx->nb_qf; i++) {
+        if (vk_hwctx->qf[i].flags & VK_QUEUE_COMPUTE_BIT) {
+            queue_family = vk_hwctx->qf[i].idx;
+            break;
+        }
+    }
+    if (queue_family < 0) {
+        av_log(ctx, AV_LOG_ERROR, "No compute queue family found.\n");
+        return AVERROR(EINVAL);
+    }
+
+    // Share FFmpeg's Vulkan device with libvmaf â€” no duplicate instance/device
+    VmafVulkanConfiguration vk_cfg = {
+        .vk_instance        = vk_hwctx->inst,
+        .vk_physical_device = vk_hwctx->phys_dev,
+        .vk_device          = vk_hwctx->act_dev,
+        .queue_family       = queue_family,
+        .queue_index        = 0,
+    };
+
+    VmafConfiguration cfg = {
+        .log_level = log_level_map(av_log_get_level()),
+        .n_subsample = s->n_subsample,
+        .n_threads = s->n_threads,
+    };
+
+    err = vmaf_init(&s->vmaf, cfg);
+    if (err)
+        return AVERROR(EINVAL);
+
+    err = vmaf_vulkan_state_init(&s->vk_state, vk_cfg);
+    if (err) {
+        av_log(ctx, AV_LOG_ERROR,
+               "vmaf_vulkan_state_init failed: %d\n", err);
+        return AVERROR_EXTERNAL;
+    }
+
+    err = vmaf_vulkan_import_state(s->vmaf, s->vk_state);
+    if (err) {
+        av_log(ctx, AV_LOG_ERROR,
+               "vmaf_vulkan_import_state failed: %d\n", err);
+        return AVERROR_EXTERNAL;
+    }
+
+    err = parse_models(ctx);
+    if (err)
+        return err;
+
+    err = parse_features(ctx);
+    if (err)
+        return err;
+
+    return config_output(outlink);
+}
+
+static const AVFilterPad libvmaf_outputs_vulkan[] = {
+    {
+        .name         = "default",
+        .type         = AVMEDIA_TYPE_VIDEO,
+        .config_props = config_props_vulkan,
+    },
+};
+
+const FFFilter ff_vf_libvmaf_vulkan = {
+    .p.name         = "libvmaf_vulkan",
+    .p.description  = NULL_IF_CONFIG_SMALL("Calculate the VMAF between two video "
+                                           "streams using Vulkan GPU acceleration."),
+    .p.priv_class   = &libvmaf_class,
+    .preinit        = libvmaf_framesync_preinit,
+    .init           = init_vulkan,
+    .uninit         = uninit,
+    .activate       = activate,
+    .priv_size      = sizeof(LIBVMAFContext),
+    FILTER_INPUTS(libvmaf_inputs),
+    FILTER_OUTPUTS(libvmaf_outputs_vulkan),
+    FILTER_SINGLE_PIXFMT(AV_PIX_FMT_VULKAN),
+    .flags_internal = FF_FILTER_FLAG_HWFRAME_AWARE,
+};
+#endif
